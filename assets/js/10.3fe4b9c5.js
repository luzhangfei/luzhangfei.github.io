(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{173:function(a,t,r){"use strict";r.r(t);var e=r(0),s=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"java-设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-设计模式","aria-hidden":"true"}},[a._v("#")]),a._v(" Java 设计模式")]),a._v(" "),r("h2",{attrs:{id:"设计原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 设计原则")]),a._v(" "),r("h3",{attrs:{id:"单一职责原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 单一职责原则")]),a._v(" "),r("p",[a._v("一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。")]),a._v(" "),r("h3",{attrs:{id:"开闭原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 开闭原则")]),a._v(" "),r("p",[a._v("一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。")]),a._v(" "),r("h3",{attrs:{id:"里氏代换原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#里氏代换原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 里氏代换原则")]),a._v(" "),r("p",[a._v("所有引用基类（父类）的地方必须能透明地使用其子类的对象")]),a._v(" "),r("h3",{attrs:{id:"依赖倒转原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒转原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 依赖倒转原则")]),a._v(" "),r("p",[a._v("抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。")]),a._v(" "),r("h3",{attrs:{id:"接口隔离原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 接口隔离原则")]),a._v(" "),r("p",[a._v("根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：")]),a._v(" "),r("ul",[r("li",[a._v("当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。")]),a._v(" "),r("li",[a._v("如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。")])]),a._v(" "),r("h3",{attrs:{id:"合成复用原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合成复用原则","aria-hidden":"true"}},[a._v("#")]),a._v(" 合成复用原则")]),a._v(" "),r("p",[a._v("合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之：复用时要尽量使用组合/聚合关系（关联关系），少用继承。\n在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。\n通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。")]),a._v(" "),r("h3",{attrs:{id:"迪米特法则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则","aria-hidden":"true"}},[a._v("#")]),a._v(" 迪米特法则")]),a._v(" "),r("p",[a._v("一个软件实体应当尽可能少地与其他实体发生相互作用。")])])}],!1,null,null,null);s.options.__file="README.md";t.default=s.exports}}]);